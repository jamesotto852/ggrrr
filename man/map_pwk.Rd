% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map_pwk.R
\name{map_pwk}
\alias{map_pwk}
\alias{imap_pwk}
\alias{map2_pwk}
\alias{pmap_pwk}
\title{Apply a plotting function, returning a patchwork}
\usage{
map_pwk(.x, .f, ..., .patchwork_options = list())

imap_pwk(.x, .f, ..., .patchwork_options = list())

map2_pwk(.x, .y, .f, ..., .patchwork_options = list())

pmap_pwk(.l, .f, ..., .patchwork_options = list())
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.patchwork_options}{A list of arguments passed to \code{patchwork::wrap_plots()},
useful for arranging plots in the resulting patchwork object. See examples for details.}
}
\value{
A \code{patchwork} object
}
\description{
The \verb{*_pwk()} functions apply a function \code{f} element-wise across various objects,
converting the output into a patchwork object via \code{patchwork::wrap_plots()}.
\code{f} should return a \code{ggplot} object, or some other object which works with patchwork
(e.g. the results of \code{patchwork::wrap_elements()}).
For details on the use of each function, see \code{?purrr::map}.
}
\examples{
library("ggplot2")

# Plot different linear models w/ geom_smooth() ----

df <- data.frame(x = runif(100, -10, 10))
df$y <- with(df, 2 + x + .2 * x^2  - .05 * x^3+ rnorm(100, sd = 5))

# plotting the data
ggplot(df, aes(x, y)) +
  geom_point()

# f: formula -> ggplot object
f <- function(formula) {
  ggplot(df, aes(x, y)) +
    geom_smooth(formula = formula, method = "lm")
}

# list of formulas to apply f over
formulas <- list(
  y ~ x,
  y ~ poly(x, 2),
  y ~ poly(x, 3)
)

map_pwk(formulas, f)

# can specify number of columns via .patchwork_options
map_pwk(formulas, f, .patchwork_options = list(ncol = 1))


# Map over data.frame rows with pmap_pwk() ----

geoms <- list(
  geom_point(size = .5),
  geom_bin2d(),
  geom_density2d_filled()
)

datasets <- list(

  # Unimodal
  data.frame(
    x = rnorm(4e3),
    y = rnorm(4e3)
  ),

  # Bimodal
  data.frame(
    x = rnorm(4e3) + rep(c(-2, 2), length.out = 1e3),
    y = rnorm(4e3)
  ),

  # Constrained Support
  data.frame(
    x = rexp(4e3),
    y = rexp(4e3)
  )

)

# plot a geom + data combination
f <- function(geom, data) {
  ggplot(data, aes(x, y)) +
    geom
}

# cross product between geoms and datasets,
# saved as a tibble
df_nested <-
  tidyr::expand_grid(
    geom = geoms,
    data = datasets
  )

# use pmap_pwk to apply across rows of tibble or data.frame
# patchwork's `&` to manipulate the patchwork object
pmap_pwk(df_nested, f, .patchwork_options = list(ncol = 3)) &
  theme(
    legend.position = "none",
    axis.ticks = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank()
  )

}
