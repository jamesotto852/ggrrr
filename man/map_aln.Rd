% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map_aln.R
\name{map_aln}
\alias{map_aln}
\alias{imap_aln}
\alias{map2_aln}
\alias{pmap_aln}
\title{Apply a plotting function, returning a list of aligned plots}
\usage{
map_aln(.x, .f, ...)

imap_aln(.x, .f, ...)

map2_aln(.x, .y, .f, ...)

pmap_aln(.l, .f, ...)
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{A function, formula, or vector (not necessarily atomic).

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of \code{.default} will be returned.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.y}{A list or atomic vector the same length as \code{.x}.}

\item{.l}{A list of vectors, such as a data frame. The length of \code{.l}
determines the number of arguments that \code{.f} will be called with. List
names will be used if present.}
}
\value{
A \code{patchwork} object
}
\description{
The \verb{*_aln()} functions apply a function \code{f} element-wise across various objects,
converting the output into a list of plots with equal spacing and alignment via \code{patchwork::align_patches()}.
\code{f} should return a \code{ggplot} object, no other output is allowed.
}
\examples{
library("ggplot2")

# Plot different linear models w/ geom_smooth() ----

df <- data.frame(x = runif(100, -10, 10))
df$y <- with(df, 2 + x + .2 * x^2  - .05 * x^3+ rnorm(100, sd = 5))

# plotting the data
ggplot(df, aes(x, y)) +
  geom_point()

# f: formula -> ggplot object
f <- function(formula) {
  ggplot(df, aes(x, y)) +
    geom_smooth(formula = formula, method = "lm")
}

# list of formulas to apply f over
formulas <- list(
  y ~ x,
  y ~ poly(x, 2),
  y ~ poly(x, 3)
)

plots <- map_aln(formulas, f)

plots[[1]]
plots[[2]]
plots[[3]]

}
